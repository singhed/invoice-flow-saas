# Internationalization (i18n)

This project ships with simple, dependency-free internationalization for the web app. It currently supports:

- English (code: `en`)
- Spanish (code: `es`)
- Chinese (Mandarin) (code: `zh`)

The implementation focuses on:

- Server-first translations using Next.js App Router
- A lightweight dictionary-based approach (no external library)
- A language switcher that persists selection in a cookie
- Clean fallback behavior to English

See also: i18n strings reference with all keys and translations in docs/I18N_STRINGS.md.

## Overview of the Implementation

- Dictionaries live at `apps/web/src/i18n/dictionaries.ts`.
- Server utilities live at `apps/web/src/i18n/server.ts`.
- Generic i18n helpers live at `apps/web/src/i18n/index.ts`.
- UI language selector is implemented at `apps/web/src/components/LanguageSwitcher.tsx`.
- The `<Navbar />` is a Server Component that renders translated labels and includes the language selector.
- The root `layout.tsx` sets the `<html lang="...">` attribute based on the selected locale.

## How Language Is Resolved

- The current locale is stored in a cookie named `locale` (values: `en`, `es`, `zh`).
- On the server, `getCurrentLocale()` reads the cookie using Next's `cookies()` API and falls back to `en` if:
  - the cookie is not present, or
  - the value is not supported.
- On the client, the language selector writes this cookie and triggers a refresh to re-render server components with the new language.

## Using Translations in Components

Translations are performed with a translator function created by `createTranslator(locale)`.

Example (Server Component):

```tsx
import { createTranslator } from "@/i18n";
import { getCurrentLocale } from "@/i18n/server";

export default async function Page() {
  const t = createTranslator(getCurrentLocale());
  return <h1>{t("home.features.title")}</h1>;
}
```

For formatting variables, pass a values object:

```tsx
const t = createTranslator(getCurrentLocale());
const appName = "Expense Management";
<p>{t("home.hero.subtitle", { appName })}</p>;
```

This replaces `{appName}` placeholders in the dictionary with the supplied value.

## Adding a New Language

1. Open `apps/web/src/i18n/dictionaries.ts`.
2. Add the new language code to `Locale` and `SUPPORTED_LOCALES`.
3. Add a new entry under `DICTIONARIES[<code>]` that mirrors the existing key structure.
4. Optionally add a human-readable label under `language` (e.g., native label) for the selector.
5. Expose the language in `LANGUAGES` inside `apps/web/src/i18n/index.ts` so it appears in the `<LanguageSwitcher />`.
6. Add the new translations to the documentation in `docs/I18N_STRINGS.md`.

Example snippet:

```ts
export type Locale = "en" | "es" | "zh" | "fr";
export const SUPPORTED_LOCALES: Locale[] = ["en", "es", "zh", "fr"];

export const DICTIONARIES: Record<Locale, Messages> = {
  // ... existing ...
  fr: {
    language: { label: "Langue", en: "Anglais", es: "Espagnol", zh: "Chinois", fr: "Français" },
    navbar: { home: "Accueil", invoices: "Factures", docs: "Docs", get_started: "Commencer", beta: "Bêta" },
    // replicate all keys used by the app
  },
};
```

Also remember to update:

```ts
export const LANGUAGES = [
  { code: "en", label: DICTIONARIES.en.language.en as string },
  { code: "es", label: DICTIONARIES.es.language.es as string },
  { code: "zh", label: DICTIONARIES.zh.language.zh as string },
  // { code: "fr", label: DICTIONARIES.fr.language.fr as string },
];
```

## Best Practices

- Keep translation keys stable; avoid embedding full sentences into code.
- Use descriptive key paths (e.g., `home.hero.title`, `invoices.error_hint`).
- Prefer placeholders for dynamic content (e.g., `{appName}`) and pass values via `t(key, { var: value })`.
- Always provide English as the fallback language.
- When adding new UI strings, add them to all dictionaries to avoid user-facing fallbacks during language switching.
- Use the documentation in `docs/I18N_STRINGS.md` to validate that all languages are covered equally.

## SEO and Accessibility

- The root `<html lang>` attribute is derived from the selected locale for proper SEO and screen reader behavior.
- The language dropdown is keyboard accessible and uses a standard `<select>` element.

## Limitations and Notes

- This is a minimal i18n solution. If you need advanced features (message plurals, date/number formatting, ICU messages, routing by locale, etc.), consider integrating a dedicated library like `next-intl` or `react-intl`.
- Client Components that need translations can either:
  - receive translated strings as props from a parent Server Component, or
  - import the dictionaries directly and determine the locale via a client-safe mechanism (e.g., reading the `locale` cookie). The current setup keeps this simple by translating primarily on the server.
